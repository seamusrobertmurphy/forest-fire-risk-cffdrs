---
title: "CFFDRS 2.0: Canadian WildFire Risk Mapping"
subtitle: "Reproducible pipeline for deriving CFFDRS-compliant fire behavior metrics in British Columbia's Okanagan Watershed"
date: 2022-02-24
author: 
  - name: Seamus Murphy
    orcid: 0000-0002-1792-0351 
    email: seamusrobertmurphy@gmail.com
abstract: > 
  This report documents development of wildfire risk mapping and behavior prediction metrics in accordance with the Canadian Forest Fire Danger Rating System (V2.0). Leveraging the new `cffdrs` package and the release of the updated Fire Danger Rating System framework](https://cwfis.cfs.nrcan.gc.ca/background/dsm/fbp), the following demonstrates a reproducible and technically aligned workflow to data acquisition, spatial covariate processing, including satellite-derived elevation, gridded climate data, and vegetation inventories, to produce fire behavior outputs. The methodology is designed to support the needs of fire managers, researchers, andwildfire operational teams by providing robust estimates of current day fire environment. This markdown was originally commissioned for preparation of submission to the [Innovative Solutions Canada](https://www.ic.gc.ca/eic/site/101.nsf/eng/00157.html) grant funding and was since updated with releases of new input data.
keywords:
  - Wildfire Risk
  - Fuel Typing
  - Canadian Forest Fire Danger Rating System (V2.0)
format:
  html:
    toc: true
    toc-location: right
    toc-title: "**Contents**"
    toc-depth: 5
    toc-expand: 4
    theme: [minimal, styles.scss]
    embed-resources: true
highlight-style: github
df-print: kable
bibliography: references.bib
engine: knitr
always_allow_html: true
css: styles/academicons--google-scholar.css
---

```{r setup}
#| warning: false
#| message: false
#| error: false
#| echo: false


pacman::p_load(
  "devtools",
  "bibtex",
  "cffdrs", "curl", "cols4all", "chromote",
  "dplyr",
  "elevatr", "ellmer",
  "gstat", "geonetwork",
  "htmltools", "httr2",
  "janitor",
  "kableExtra", "knitr",
  "lutz", 
  "mapedit",
  "ncdf4",
  "openxlsx","OpenStreetMap", "osmdata",
  "PROJ",
  "raster", "rasterVis", "reproj", "rmapshaper", "renv",
  "sf",
  "tinytex", "tmap", "tmaptools", "terra", "tmap.networks", "tmap.glyphs", "tmap.cartogram",
  "useful", "usethis", 
  "weathercan")

knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE, 
  warning = FALSE,
  error = TRUE, 
  comment = NA, 
  tidy.opts = list(
    width.cutoff = 60)
  ) 

sf::sf_use_s2(use_s2 = FALSE)
options(htmltools.dir.version = FALSE, 
        htmltools.preserve.raw = FALSE)
tmap_options(max.raster = c(plot = 9500000, view = 10000000)) # allows large raster rendering
renv::init()
```

```{css, echo=FALSE, class.source = 'foldable', eval=F}
div.column {
    display: inline-block;
    vertical-align: top;
    width: 50%;
}

#TOC::before {
  content: "";
  display: block;
  height:200px;
  width: 200px;
  background-image: url("https://avatars.githubusercontent.com/u/81122008?s=200");
  background-size: contain;
  background-position: 50% 50%;
  padding-top: 80px !important;
  background-repeat: no-repeat;
}
```

## 1. Introduction

The Canadian Forest Fire Danger Rating System (CFFDRS) has served as the scientific foundation for wildland fire management in Canada. The next generation of the CFFDRS (V2.0) includes several enhancements designed to incorporate new data sources and address the increasing complexity of contemporary fire management [@boucher]. This report provides a reproducible pipeline using the `cffdrs` R package to derive key fire behavior metrics. Our workflow develops raster layers of fuel moisture codes and wildfire weather indices. These inputs are used to inform the stand-adjusted fine-fuel model [@wotton2007stand] and classify vegetation into fuel classes based on the BC forest fuel typing framework [@perrakis2018british; @perrakis2023improved]. The resulting fuel type rasters are compiled to predict fire behavior, from which we derive Head Fire Index (HFI) and Fire Intensity (FI) maps for the Okanagan Watershed Basin for the 2021 fire season. The full workflow is illustrated in the flowchart below.

![Figure 1: Tentative Workflow](assets/PNG/cffdrs-workflow.png){fig-align="center"}

#### Clone repository

This guide enables reproducible analysis by cloning the supporting repository using the following bash commands in your terminal:

``` r
git clone https://github.com/seamusrobertmurphy/wildfire-fuel-mapping-CFFDRS-2.0.git
```

## 2. Method

#### Import AOI Data

Two input options for selecting AOI were explored below: 1) uploading AOI boundary file and 2) choosing point location as centre of 10km LxW bounding box. We downloaded the Okanagan Watershed boundary [(FWA ID:212)](https://www2.gov.bc.ca/gov/content/data/geographic-data-services/topographic-data/freshwater) and transformed into spatVector for implementing workflow using `terra` functions.

```{r}
#| warning: false
#| message: false
#| error: false
#| echo: true
#| eval: false

download.file(
  url      = "https://data.hydrosheds.org/file/HydroBASINS/customized_with_lakes/hybas_lake_na_lev06_v1c.zip",
  destfile = "./assets/SHP/watersheds_na_l6.zip",
  mode     = "wb"
  )

unzip(
  zipfile = "./assets/SHP/watersheds_na_l6.zip",
  exdir   = "./assets/SHP/"
  )

xy         = "49.95,-119.43"
watersheds = sf::st_read("./assets/SHP/watersheds_na_l6/hybas_lake_na_lev06_v1c.shp")
aoi_xy     = sf::st_read("./assets/SHP/aoi_xy.shp")
aoi        = watersheds |> sf::st_intersection(aoi_xy) 
sf::st_write(aoi, "./assets/SHP/aoi_watershed.shp")

tmap::tmap_mode("view")
tmap::tm_shape(aoi) + tmap::tm_borders(col="purple", lwd=2) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("AOI Waterhsed", size=.8) + 
  tmap::tm_basemap("Esri.WorldImagery") 
```

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: false
#| eval: true

aoi = sf::st_read("./assets/SHP/aoi_watershed.shp", quiet=T)

tmap::tmap_mode("view")
tmap::tm_shape(aoi) + tmap::tm_borders(col="purple", lwd=2) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("AOI Waterhsed", size=.8) + 
  #tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT","top"))+
  #tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  #tmap::tm_layout(legend.position=c("left", "top"), legend.bg.color = "white") +
  tmap::tm_basemap("Esri.WorldImagery") 
  #tmap::tm_basemap("OpenStreetMap") 
  #tmap::tm_basemap("OpenTopoMap") 
```

#### Import DEM Data

Topography is a primary driver of fire behavior, influencing fire spread, intensity, and fuel moisture. This section details a reproducible workflow for acquiring Digital Elevation Model (DEM) data and its derivatives. The following chunk begins by acquiring a `DEM` raster for the `AOI` using the `elevatr` package [@elevatr]. From this dataset, slope and aspect rasters were derived. All three layers were then processed using the `terra` package to ensure a consistent spatial alignment and extent. Make sure to toggle layers on and off to inspect visually.

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: true
#| eval: false

elev  = elevatr::get_elev_raster(aoi, z=11) # res==zoom -> https://github.com/tilezen/joerd/blob/master/docs/data-sources.md#what-is-the-ground-resolution
raster::writeRaster(elev, "./assets/TIF/elevation.tif", overwrite=T)

slope = raster::terrain(elev, 
  opt       = "slope", 
  neighbors = 8,
  overwrite = T,
  filename  = "./assets/TIF/slope.tif"
  )

aspect = raster::terrain(elev, 
  opt       = "aspect", 
  neighbors = 8,
  overwrite = T,
  filename  = "./assets/TIF/aspect.tif"
  )

# Tidy elevation rasters
elev  = terra::rast("./assets/TIF/elevation.tif") |> terra::project("EPSG:3857")
slope = terra::rast("./assets/TIF/slope.tif") |> terra::project("EPSG:3857")
aspect= terra::rast("./assets/TIF/aspect.tif") |> terra::project("EPSG:3857")
slope = terra::resample(slope, elev, method="bilinear")
aspect= terra::resample(aspect, elev, method="bilinear")
slope = terra::mask(slope, terra::vect(sf::st_transform(aoi, "EPSG:3857")))
aspect= terra::mask(aspect, terra::vect(sf::st_transform(aoi, "EPSG:3857")))
elev  = terra::mask(elev, terra::vect(sf::st_transform(aoi, "EPSG:3857")))
raster::writeRaster(elev, "./assets/TIF/elevation.tif", overwrite=T)
raster::writeRaster(slope, "./assets/TIF/slope.tif", overwrite=T)
raster::writeRaster(aspect, "./assets/TIF/aspect.tif", overwrite=T)


tmap::tm_shape(elev)+ tm_raster(style= "cont", title="Elevation ASL", palette="viridis")+
  tmap::tm_shape(slope)+ tm_raster(style= "cont", title="Slope", palette="Oranges") +
  tmap::tm_shape(aoi)+ tm_borders(col="purple", lwd = 2) +
  tmap::tm_compass(type = "8star", position = c("left", "top")) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("Elevation Rasters", size=0.8) +
  tmap::tm_basemap("Esri.WorldImagery") 
```

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: false
#| eval: true
elev  = terra::rast("./assets/TIF/elevation.tif")
slope = terra::rast("./assets/TIF/slope.tif")
aspect = terra::rast("./assets/TIF/aspect.tif")

tmap::tm_shape(elev)+ tm_raster(style= "cont", title="Elevation ASL", palette="viridis")+
  tmap::tm_shape(slope)+ tm_raster(style= "cont", title="Slope", palette="Oranges") +
  tmap::tm_shape(aoi)+ tm_borders(col="purple", lwd = 2) +
  tmap::tm_compass(type = "8star", position = c("left", "top")) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("Elevation Rasters", size=.8) +
  tmap::tm_basemap("Esri.WorldImagery") 

```

#### Import Climate Data

Climate data, a fundamental input for wildfire weather calculations, is sourced from Environment and Climate Change Canada using the `weathercan` package. This approach replaces the manual data sourcing from platforms with reproducible, verifiable solution. The workflow begins by searching for all weather stations within a specified radius of the AOI. Hourly data for these stations is downloaded for the defined date range and then aggregated to a single mean value for each station for the target period. The cleaned, point-based spatial data is converted into continuous raster layers for each input variable, which are derived using Inverse Distance Weighting (IDW) method via a `gstat` model and the `terra::interpolate` function. The resulting outputs of mean daily temperature, precipitation, relative humidity, and wind speed are then masked to the AOI and saved for use in the next stages of the analysis.

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: true
#| eval: false

# Search weather stations
stations_100km = weathercan::stations_search(
  coords  = c(49.95,-119.43), 
  interval= "day",
  dist    = 100)

# Parse by station
stations_ids_unique <- stations_100km |>
  dplyr::pull(station_id) |> unique()

# Download data for all selected stations
climate_tbl <- weathercan::weather_dl(
  station_ids = stations_ids_unique,
  start = "2021-06-01",
  end = "2021-10-01",
  interval = "hour") # relative humidity in hourly only

# Aggregate by station
aggregated_data <- climate_tbl |>
  dplyr::group_by(station_id, lat, lon) |>
  dplyr::summarise(
    mean_temp = mean(temp, na.rm = TRUE),
    mean_prec = mean(prec_amt, na.rm = TRUE),
    mean_rh   = mean(rel_hum, na.rm = TRUE),
    mean_ws   = mean(wind_spd, na.rm = TRUE)
  ) |>
  dplyr::ungroup()

# Convert to spatial and filter missing stations
climate_sf <- aggregated_data |>
  dplyr::filter(
    !is.nan(mean_temp),
    !is.nan(mean_prec),
    !is.nan(mean_rh),
    !is.nan(mean_ws)
  ) |>
  sf::st_as_sf(
    coords = c("lon", "lat"),
    crs = 4326
  ) |>
  sf::st_transform("EPSG:3857")

# Derive raster template to interpolate on top of
raster_template <- terra::rast("./assets/TIF/elevation.tif")

# Derive function to handle `sf` weather station data
interpolate_stations <- function(model, x, crs, ...) {
	v <- st_as_sf(x, coords = c("x", "y"), crs = crs)
	p <- predict(model, v, ...)
	as.data.frame(p)[, 1:2]
  }

# Create Inverse Distance Weighting models using gstat.pkg
temp_idw <- gstat(
  formula = mean_temp ~ 1, 
  locations = climate_sf,
  nmax = 8, 
  set = list(idp = 2.0) 
  )

prec_idw <- gstat(
  formula = mean_prec ~ 1, 
  locations = climate_sf,
  nmax = 8, 
  set = list(idp = 2.0) 
  )

rh_idw <- gstat(
  formula = mean_rh ~ 1, 
  locations = climate_sf,
  nmax = 8, 
  set = list(idp = 2.0) 
  )

ws_idw <- gstat(
  formula = mean_ws ~ 1, 
  locations = climate_sf,
  nmax = 8, 
  set = list(idp = 2.0) 
  )


# Spatially interpolate using terra.pkg
temp_rast <- terra::interpolate(
  object = raster_template,
  model = temp_idw,
  fun = interpolate_stations,
  crs = "EPSG:3857",
  debug.level = 0
)

prec_rast <- terra::interpolate(
  object = raster_template,
  model = prec_idw,
  fun = interpolate_stations,
  crs = "EPSG:3857",
  debug.level = 0
)

rh_rast <- terra::interpolate(
  object = raster_template,
  model = rh_idw,
  fun = interpolate_stations,
  crs = "EPSG:3857",
  debug.level = 0
)

ws_rast <- terra::interpolate(
  object = raster_template,
  model = ws_idw,
  fun = interpolate_stations,
  crs = "EPSG:3857",
  debug.level = 0
)

# Tidy, save, and visualize
temp    = terra::mask(temp_rast, terra::vect(sf::st_transform(aoi, "EPSG:3857")))
prec    = terra::mask(prec_rast, terra::vect(sf::st_transform(aoi, "EPSG:3857")))
rh      = terra::mask(rh_rast, terra::vect(sf::st_transform(aoi, "EPSG:3857")))
ws      = terra::mask(ws_rast, terra::vect(sf::st_transform(aoi, "EPSG:3857")))

terra::writeRaster(temp, "./assets/TIF/temp.tif", overwrite=T)
terra::writeRaster(prec, "./assets/TIF/prec.tif", overwrite=T)
terra::writeRaster(rh, "./assets/TIF/rh.tif", overwrite=T)
terra::writeRaster(ws, "./assets/TIF/ws.tif", overwrite=T)

tmap::tmap_mode("plot")
tmap::tm_shape(temp)+ tm_raster(style= "cont", 
  title="Mean Daily Temperature (°C 2m AGL)", palette="Oranges")+
  tmap::tm_shape(aoi)+ tm_borders(col="purple", lwd = 2) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT","top"))+
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) 

tmap::tm_shape(prec)+ tm_raster(style= "cont", 
  title="Mean Daily Precipitation (mm^3/day)", palette="Oranges") +
  tmap::tm_shape(aoi)+ tm_borders(col="purple", lwd = 2) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT","top"))+
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) 
  
tmap::tm_shape(rh)+ tm_raster(style= "cont", 
  title="Relative Humidity (NCDC 2m AGL)", palette="Oranges") +
  tmap::tm_shape(aoi)+ tm_borders(col="purple", lwd = 2) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT","top"))+
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) 

tmap::tm_shape(ws)+ tm_raster(style= "cont", 
  title="Wind Speed (m/s 10m AGL)", palette="Oranges") +
  tmap::tm_shape(aoi)+ tm_borders(col="purple", lwd = 2) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT","top"))+
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) 
```

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: false
#| eval: true

# Specific ordering is required by ccfdrs pkg
temp  = terra::rast("./assets/TIF/temp.tif")[[1]]
rh    = terra::rast("./assets/TIF/rh.tif")[[1]]
prec  = terra::rast("./assets/TIF/prec.tif")[[1]]
ws    = terra::rast("./assets/TIF/ws.tif")[[1]]

names(temp) = "temp"
names(rh)   = "rh"
names(prec) = "prec"
names(ws)   = "ws"
  
tmap::tmap_mode("view")
tmap::tm_shape(temp)+ tm_raster(style= "cont", 
  title="Mean Daily Temperature (°C 2m AGL)", palette="Oranges")+
  tmap::tm_shape(prec)+ tm_raster(style= "cont", 
  title="Mean Daily Precipitation (mm^3/day)", palette="Blues") +
  tmap::tm_shape(rh)+ tm_raster(style= "cont", 
  title="Relative Humidity (NCDC 2m AGL)", palette="Greens") +
  tmap::tm_shape(ws)+ tm_raster(style= "cont", 
  title="Wind Speed (m/s 10m AGL)", palette="Purples") +
  tmap::tm_shape(aoi)+ tm_borders(col="purple", lwd = 2) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT","top"))+
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) 
```

## 3. Results

#### Derive Fuel Type Maps

The Fire Behavior Prediction (FBP) system relies on a detailed and accurate classification of fuel types. This section demonstrates development of fuel maps from the publicly available BC Vegetation Resource Inventory (VRI) dataset downloaded from [BC Data Catalog](https://catalogue.data.gov.bc.ca/dataset/vri-2024-forest-vegetation-composite-polygons/resource/85724845-3973-4a26-b715-100306768bbc).

To ensure our inputs are correctly formatted for the `cffdrs` package, we reviewed the included example datasets, `test_fwi` and `test_fbp`, which serve as templates guiding input requirements and structure, as documented in the VRI data dictionary [here](https://www2.gov.bc.ca/assets/gov/farming-natural-resources-and-industry/forestry/stewardship/forest-analysis-inventory/data-management/standards/vegcomp_poly_rank1_data_dictionaryv5_2019.pdf).

Following the workflow of Wotton and Beverly's stand-adjusted fine-fuel moisture model [@wotton2007stand] and more recent methodologies [@perrakis2018british], we classified the VRI attributes into distinct fuel categories. This process extracted predictor variables, such as stand type and density, and applied a filtering process to classify fuel categories that are consistent with the FBP system. The resulting classified vector layers serve as the foundational fuel maps for all subsequent fire behavior predictions.

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: true
#| eval: false

# Download
download.file(destfile = "./assets/VRI/vri_2024.zip", mode = "wb",
  url = "https://pub.data.gov.bc.ca/datasets/02dba161-fdb7-48ae-a4bb-bd6ef017c36d/current/VEG_COMP_POLY_AND_LAYER_2024.gdb.zip")
unzip(zipfile = "./assets/VRI/vri_2024.zip",
  exdir = "./assets/VRI/")

# Tidy & save
vri_2024  = sf::st_read("./assets/VRI/vri_2024.shp") |> 
  sf::st_intersects(sf::st_transform(aoi, "EPSG:3005")) |>
  sf::st_transform("EPSG:3857")
sf::st_write(vri_2024, ".assets/VRI/vri_2024_3857.shp")

# Input Requirements
library(cffdrs)
print(as_tibble(test_fwi), n = 10)
print(as_tibble(test_fbp), n = 10)
```

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: false
#| eval: true
print(as_tibble(test_fwi), n = 10)
print(as_tibble(test_fbp), n = 10)
```

Wotton and Beverly's model of stand-adjusted fine fuel moisture content requires five predictor variables [@wotton2007stand]. Two of these predictors were extracted from the the VRI dataset including stand type (`SPEC_CD_1`) and stand density (`LIVE_STEMS`). Rough scale criteria were used in a filtering process to classify fuel categories similar to those used in Wotton and Beverley's model [@wotton2007stand] and more recent workflows [@perrakis2018british].

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: true
#| eval: false

vri = st_read("./assets/VRI/vri_2022_3857.shp", quiet=T) |> 
  sf::st_make_valid() |>
  dplyr::select(c(
    "BCLCS_LEVE", 
    "BCLCS_LE_1", 
    "BCLCS_LE_2",
    "BCLCS_LE_3",
    "BCLCS_LE_4",
    "SPECIES_CD", "SPECIES_PC", 
    "BEC_ZONE_C", 
    "VRI_LIVE_S"))
  
# Additional fuel typing layers available but not yet explored:
# SHRB_HT, SHRB_CC, HERB_TYPE, HERB_COVER, HERB_PCT, #NON_VEG_1, 
# N_LOG_DATE, DEAD_PCT, HRVSTDT, SITE_INDEX, PROJ_HT_1, #SPEC_AGE_1, 
# DEAD_PCT, STEM_HA_CD, DEAD_STEMS, NVEG_COV_1)
wotton_fuel_class = vri |>
  mutate(fuel_type = case_when((BCLCS_LEVE != "V") ~ 0,
  (BCLCS_LEVE == "V" & BCLCS_LE_3 == "TB") ~ 1, 
  (BCLCS_LEVE == "V" & SPECIES_CD == "FD" | SPECIES_CD == "FDC" | SPECIES_CD == "FDI") ~ 2,
  (BCLCS_LEVE == "V" & SPECIES_PC <= 80) ~ 3,
  (BCLCS_LEVE == "V" & SPECIES_CD == "PA" | SPECIES_CD == "PL" | SPECIES_CD == "PLC" | SPECIES_CD == "PY") ~ 4,
  (BCLCS_LEVE == "V" & BCLCS_LE_4 =="SP" | SPECIES_CD == "SB" | SPECIES_CD == "SX" | 
      SPECIES_CD == "SW" | SPECIES_CD == "S" | BEC_ZONE_C == "BWBS" | BEC_ZONE_C == "SWB") ~ 5, TRUE ~ 0))
Wotton_fuel_N  = dplyr::filter(vri, BCLCS_LEVE =="N")
Wotton_fuel_HW = dplyr::filter(vri, BCLCS_LE_3=="TB")
Wotton_fuel_Df = dplyr::filter(vri, BCLCS_LEVE == "V" & SPECIES_CD == "FD" | SPECIES_CD == "FDC" | SPECIES_CD == "FDI")
Wotton_fuel_MW = dplyr::filter(vri, BCLCS_LEVE == "V" & SPECIES_PC <= 80)
Wotton_fuel_PI = dplyr::filter(vri, BCLCS_LEVE == "V" & SPECIES_CD == "PA" | SPECIES_CD == "PL" | SPECIES_CD == "PLC" | SPECIES_CD == "PY")
Wotton_fuel_SP = dplyr::filter(vri, BCLCS_LEVE == "V" & BCLCS_LE_4 =="SP" | SPECIES_CD == "SB" | 
    SPECIES_CD == "SX" | SPECIES_CD == "SW" | SPECIES_CD == "S" | BEC_ZONE_C == "BWBS" | BEC_ZONE_C == "SWB")

density = vri["VRI_LIVE_S"] |> dplyr::mutate(VRI_LIVE_S = as.numeric(VRI_LIVE_S))
density = rename(density, density = VRI_LIVE_S)
sf::st_write(density, "./assets/VRI/density.shp")

tmap::tm_shape(density) + tm_polygons(fill = "density", 
  fill.scale = tm_scale_continuous(values = "viridis"), lwd=0, 
  tm_title("Live Tree Density (Stems/ha"))
tmap::tm_shape(Wotton_fuel_N) + tm_polygons(fill = "brown", lwd=0)
tmap::tm_shape(Wotton_fuel_PI) + tm_polygons(fill = "yellow", lwd=0)
tmap::tm_shape(Wotton_fuel_HW) + tm_polygons(fill = "green", lwd=0)
tmap::tm_shape(Wotton_fuel_Df) + tm_polygons(fill = "purple", lwd=0)
tmap::tm_shape(Wotton_fuel_MW) + tm_polygons(fill = "blue", lwd=0)
tmap::tm_shape(Wotton_fuel_SP) + tm_polygons(fill = "darkgreen", lwd=0)
```

```{r}
#| layout-ncol: 2
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: false
#| eval: true

density = sf::st_read("./assets/VRI/density.shp", quiet=T)
Wotton_fuel_N = sf::st_read("./assets/VRI/Wotton_fuel_N.shp", quiet=T)
Wotton_fuel_PI = sf::st_read("./assets/VRI/Wotton_fuel_PI.shp", quiet=T)
Wotton_fuel_HW = sf::st_read("./assets/VRI/Wotton_fuel_HW.shp", quiet=T)
Wotton_fuel_Df = sf::st_read("./assets/VRI/Wotton_fuel_Df.shp", quiet=T)
Wotton_fuel_MW = sf::st_read("./assets/VRI/Wotton_fuel_MW.shp", quiet=T)
Wotton_fuel_SP = sf::st_read("./assets/VRI/Wotton_fuel_SP.shp", quiet=T)

tmap::tmap_mode("plot")
tmap::tm_shape(Wotton_fuel_N) + tm_polygons(fill = "brown", lwd=0) + 
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("Non-Vegetation Fuel Free")
tmap::tm_shape(Wotton_fuel_PI) + tm_polygons(fill = "orange", lwd=0) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("Pine-Stand Fuel")
tmap::tm_shape(Wotton_fuel_HW) + tm_polygons(fill = "black", lwd=0) + 
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("Hardwood Fuel")
tmap::tm_shape(Wotton_fuel_Df) + tm_polygons(fill = "purple", lwd=0) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("Fir-Stand Fuel")
tmap::tm_shape(Wotton_fuel_MW) + tm_polygons(fill = "blue", lwd=0) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("Mixed Species Fuel")
tmap::tm_shape(Wotton_fuel_SP) + tm_polygons(fill = "darkgreen", lwd=0) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_title("Spruce-Stand Fuel")
```

#### Derive Fire Weather Maps

A raster stack of interpolated climate covariates was fitted to the `fwiRaster` function with `out="all"` operator. This produced raster results for Initial Spread Index (`isi`), and Build-up Index (`bui`) and other indices required in FBP calculations. This is as far as we could get and could only generate these CFFDRS outputs for generic landcover rasters; these scores need to be tuned for each fuel type area.

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: true
#| eval: false

temp   = terra::rast("./assets/TIF/temp.tif")[[1]]
rh     = terra::rast("./assets/TIF/rh.tif")[[1]]
prec   = terra::rast("./assets/TIF/prec.tif")[[1]]
ws     = terra::rast("./assets/TIF/ws.tif")[[1]]
names(temp)   = 'temp'
names(rh)     = 'rh'
names(ws)     = 'ws'
names(prec)   = 'prec'

# Correct ordering is necessary
stack = c(temp, rh, ws, prec)

# Derive CFFDRS predictions
fwi_outputs = cffdrs::fwiRaster(stack, out = "all")

# Save as raster brick
terra::writeRaster(fwi_outputs, "./assets/TIF/fwi_outputs.tif", overwrite=T)
```

```{r}
#| layout-ncol: 3
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: false
#| eval: true

stems = sf::st_read("./assets/VRI/density.shp", quiet=T)
fwi_outputs = terra::rast("./assets/TIF/fwi_outputs.tif")
#names(fwi_outputs) # => "TEMP" "RH"   "WS"   "PREC" "FFMC" "DMC"  "DC"   "ISI"  "BUI"  "FWI"  "DSR" 

tmap::tmap_mode("plot")
tmap::tm_shape(fwi_outputs[["FFMC"]]) + tm_raster(style="cont", palette="inferno") + 
  tmap::tm_title("Fine Fuel Moisture Code") +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5)

tmap::tm_shape(fwi_outputs[["DMC"]]) + tm_raster(style="cont", palette="inferno") + 
  tmap::tm_title("Duff Moisture Code") +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5)

tmap::tm_shape(fwi_outputs[["DC"]]) + tm_raster(style="cont", palette="inferno") + 
  tmap::tm_title("Drought Code") +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5)

tmap::tm_shape(fwi_outputs[["ISI"]]) + tm_raster(style="cont", palette="inferno") + 
  tmap::tm_title("Initial Spread Index") +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5)

tmap::tm_shape(fwi_outputs[["BUI"]]) + tm_raster(style="cont", palette="inferno") + 
  tmap::tm_title("Buildup Index") +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5)

tmap::tm_shape(fwi_outputs[["FWI"]]) + tm_raster(style="cont", palette="inferno") + 
  tmap::tm_title("Fire Weather Index") +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_scale_bar(c(0, 10, 20, 40), position = c("RIGHT", "BOTTOM"), text.size = .5)
```

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: false
#| eval: true
#| out.extra: "embed"

stems = sf::st_read("./assets/VRI/density.shp", quiet=T)
fwi_outputs = terra::rast("./assets/TIF/fwi_outputs.tif")

tmap::tmap_mode("view")
tmap::tm_shape(stems) + 
  tmap::tm_polygons(fill = "density", lwd = 0) +
  tmap::tm_shape(fwi_outputs[["DSR"]]) + 
  tmap::tm_raster(style="cont", palette = "inferno") +
  tmap::tm_graticules(lines=T, lwd=0.2, labels.rot=c(0,90))
```

```{r}
#| warning: false
#| message: false
#| error: false
#| comment: NA
#| echo: true
#| eval: false

#define mcF, mcD, ex.mod intermediate functions
mcF    = function(ffmc){147.2*(101-ffmc)/(59.5+ffmc)}
mcD    = function(dmc) {20+exp(-(dmc-244.72)/43.43)}
ex.mod = function(s1, s2, s3, ffmc, dmc) {exp(s1+s2*log(mcF(ffmc))+s3*mcD(dmc))}

#define stand-adjusted mc function to build FFMC, DMC, stand, density, season
samc<-function(ffmc, dmc, stand, density, season) {
  #Get coefficients
  CoTr1 <-c(
    0.7299,0.0202,0.7977,0.8517,0.7391,
    0.4387,-0.271,0.5065,0.5605,0.4479,
    -0.2449,-0.9546,-0.1771,-0.1231,-0.2357,
    0.1348,-0.5749,0.2026,0.2566,0.144,
    -0.1564,-0.8661,-0.0886,-0.0346,-0.1472,
    -0.84,-1.5497,-0.7722,-0.7182,-0.8308,
    0.1601,-0.55,0.2279,0.2819,0.1693,
    -0.1311,-0.8408,-0.0633,-0.0093,-0.1219,
    -0.8147,-1.5244,-0.7469,-0.6929,-0.8055)
  CoTr2 <- c(
    0.5221,0.6264,0.5042,0.3709,0.4285,
    0.7133,0.8176,0.6954,0.5621,0.6197,
    1.0462,1.1505,1.0283,0.895,0.9526,
    0.8691,0.9734,0.8512,0.7179,0.7755,
    1.0603,1.1646,1.0424,0.9091,0.9667,
    1.3932,1.4975,1.3753,1.242,1.2996,
    0.9495,1.0538,0.9316,0.7983,0.8559,
    1.1407,1.245,1.1228,0.9895,1.0471,
    1.4736,1.5779,1.4557,1.3224,1.38)
  co3 <- 0.002232
  
  #Create data frame for pulling coefs
  AllCo <-data.frame("co1"=CoTr1, "co2"=CoTr2)
  
  #Spring and Summer coefs for 'sprummer' model
  co_sp <- AllCo[1:15,]
  co_su <- AllCo[16:30,]
  
  
  if(season==1.5) {
    #spring
    c1.sprD=co_sp[(density*5-4):(density*5), 1]
    c2.sprD=co_sp[(density*5-4):(density*5), 2]
    c1=c1.sprD[stand]
    c2=c2.sprD[stand]
    mc.spr=ex.mod(c1, c2, co3, ffmc, dmc)   
    #summer 
    c1.sumD=co_su[(density*5-4):(density*5), 1]
    c2.sumD=co_su[(density*5-4):(density*5), 2]
    c3=c1.sumD[stand]
    c4=c2.sumD[stand]
    mc.sum=ex.mod(c3, c4, co3, ffmc, dmc)  
    
    #final 'sprummer' mc calc
    return(mean(c(mc.spr, mc.sum)))
    
    #for all others - spring, summer or fall
  } else {
    c1a=AllCo$co1[(season*15-14):(season*15)]
    c2a=AllCo$co2[(season*15-14):(season*15)]
    c1b=c1a[(density*5-4):(density*5)]
    c2b=c2a[(density*5-4):(density*5)]
    c1c=c1b[stand]
    c2c=c2b[stand]
    return(ex.mod(c1c, c2c, co3, ffmc, dmc))
  }
}

```

###### Runtime log

```{r}
devtools::session_info()
```